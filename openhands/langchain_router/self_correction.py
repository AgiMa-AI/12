"""
Self-Correction Mechanism for the LangChain Router.

This module implements a self-correction mechanism that can identify and fix errors
in the responses generated by language models.
"""

from typing import Dict, List, Optional, Any, Union, Callable
import logging
import re

from langchain.chains.base import Chain
from langchain.prompts import PromptTemplate
from langchain.chains import LLMChain, SequentialChain

logger = logging.getLogger(__name__)


class SelfCorrectionChain:
    """
    A chain that can identify and fix errors in responses.
    
    This chain wraps another chain and applies a self-correction mechanism
    to the output, improving the quality and accuracy of responses.
    """
    
    def __init__(
        self,
        error_detection_threshold: float = 0.7,
        max_correction_attempts: int = 2
    ):
        """
        Initialize the self-correction chain.
        
        Args:
            error_detection_threshold: Threshold for detecting errors (0.0 to 1.0)
            max_correction_attempts: Maximum number of correction attempts
        """
        self.error_detection_threshold = error_detection_threshold
        self.max_correction_attempts = max_correction_attempts
        
        # Define the prompt for error detection
        self.error_detection_template = """
        Review the following response to a user query and identify any errors,
        inconsistencies, or problematic content:
        
        User Query: {query}
        
        Response: {response}
        
        Carefully analyze the response for:
        1. Factual errors or inaccuracies
        2. Logical inconsistencies or contradictions
        3. Incomplete or missing information
        4. Harmful, biased, or inappropriate content
        5. Misunderstandings of the user's query
        
        First, rate the response on a scale from 0.0 to 1.0, where:
        - 0.0 means the response has critical errors or is completely inappropriate
        - 0.5 means the response has some issues but is partially correct
        - 1.0 means the response is excellent with no errors
        
        Then, list any specific errors or issues you identified.
        
        Format your response as:
        Rating: [0.0-1.0]
        Issues:
        - [Issue 1]
        - [Issue 2]
        ...
        """
        
        self.error_detection_prompt = PromptTemplate(
            template=self.error_detection_template,
            input_variables=["query", "response"]
        )
        
        # Define the prompt for correction
        self.correction_template = """
        The following response to a user query contains some issues that need to be fixed:
        
        User Query: {query}
        
        Original Response: {response}
        
        Issues Identified:
        {issues}
        
        Please provide a corrected version of the response that addresses all the issues
        while maintaining the helpful intent of the original response. The corrected
        response should be complete and standalone.
        
        Corrected Response:
        """
        
        self.correction_prompt = PromptTemplate(
            template=self.correction_template,
            input_variables=["query", "response", "issues"]
        )
    
    def wrap_chain(self, chain: Chain) -> Callable:
        """
        Wrap a chain with the self-correction mechanism.
        
        Args:
            chain: The chain to wrap
            
        Returns:
            A function that applies self-correction to the chain's output
        """
        def wrapped_chain(*args, **kwargs):
            # Get the original response from the chain
            original_response = chain.run(*args, **kwargs)
            
            # Extract the user query from kwargs
            query = kwargs.get("input", "")
            if not query and args:
                query = args[0]
            
            # Apply self-correction
            return self.correct(query, original_response, chain.llm)
        
        return wrapped_chain
    
    def correct(
        self,
        query: str,
        response: str,
        llm: Any,
        attempt: int = 0
    ) -> str:
        """
        Apply self-correction to a response.
        
        Args:
            query: The user's query
            response: The original response
            llm: The language model to use for correction
            attempt: The current correction attempt (for recursion)
            
        Returns:
            The corrected response
        """
        # Check if we've reached the maximum number of correction attempts
        if attempt >= self.max_correction_attempts:
            logger.info(f"Reached maximum correction attempts ({self.max_correction_attempts})")
            return response
        
        # Create the error detection chain
        error_detection_chain = LLMChain(
            llm=llm,
            prompt=self.error_detection_prompt
        )
        
        # Detect errors
        error_analysis = error_detection_chain.run(query=query, response=response)
        
        # Parse the error analysis
        rating, issues = self._parse_error_analysis(error_analysis)
        
        # If the rating is above the threshold, no correction needed
        if rating >= self.error_detection_threshold:
            logger.info(f"No correction needed (rating: {rating})")
            return response
        
        # Create the correction chain
        correction_chain = LLMChain(
            llm=llm,
            prompt=self.correction_prompt
        )
        
        # Generate the corrected response
        corrected_response = correction_chain.run(
            query=query,
            response=response,
            issues="\n".join(issues)
        )
        
        # Log the correction
        logger.info(f"Applied self-correction (rating: {rating}, issues: {len(issues)})")
        
        # Recursively check the corrected response
        return self.correct(query, corrected_response, llm, attempt + 1)
    
    def _parse_error_analysis(self, error_analysis: str) -> tuple[float, List[str]]:
        """
        Parse the error analysis output.
        
        Args:
            error_analysis: The error analysis output
            
        Returns:
            A tuple of (rating, issues)
        """
        # Extract the rating
        rating_match = re.search(r"Rating:\s*([\d.]+)", error_analysis)
        rating = float(rating_match.group(1)) if rating_match else 0.5
        
        # Extract the issues
        issues = []
        issues_section = re.search(r"Issues:(.*?)($|Rating:)", error_analysis, re.DOTALL)
        if issues_section:
            issues_text = issues_section.group(1).strip()
            issues = [issue.strip()[2:].strip() for issue in issues_text.split("\n") if issue.strip().startswith("-")]
        
        return rating, issues